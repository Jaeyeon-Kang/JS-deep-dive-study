## 12.1 함수란?
- 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
- 함수는 함수 정의를 통해 생성하고, 함수 호출을 하면 코드 블록에 담긴 문들이 일괄적으로 실행되고 실행 결과를 반환한다.
![함수의 구성 요소](image.png)

## 12.2 함수를 사용하는 이유
- 동일한 작업을 반복적으로 수행해야 한다면 같은 코드를 중복해서 여러 번 작성하는 것이 아니라 미리 정의된 함수를 재사용 하는 것이 효율적이다. 함수는 몇 번이든 호출할 수 있으므로 **코드의 재사용**이라는 측면에서 유용하다.
- 코드의 중복을 억제하고 재사용성을 높이는 함수는 **유지보수의 편의성**을 높이고 실수를 줄여 **코드의 신뢰성**을 높이는 효과가 있다.
- 적절한 함수 이름은 함수의 내부 코드를 이해하지 않고도 함수의 역할을 파악할 수 있게 돕기 때문에 **코드의 가독성**을 향상시킨다.

## 12.3 함수 리터럴
- 자바스크립트의 함수는 객체 타입의 값이므로 함수도 함수 리터럴로 생성할 수 있다. (리터럴: 값을 생성하기 위한 표기법)
  ```
  // 변수에 함수 리터럴을 할당
  var f = function add(x, y) {
    return x + y;
  }
  ```
- 함수는 객체지만 일반 객체와는 다르게 호출할 수 있고, 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다.

## 12.4 함수 정의
- 함수를 정의하는 4가지 방법
  1. 함수 선언문
  2. 함수 표현식
  3. Function 생성자 함수
  4. 화살표 함수
### 12.4.1 함수 선언문
```
// 함수 선언문
function add(x, y) {
  return x + y;
}
// 함수 호출
console.log(add(2, 5)); // 7
```
- 함수 선언문은 함수 리터럴과 형태가 동일하다. 단, 함수 리터럴은 함수 이름을 생략할 수 있으나 함수 선언문은 함수 이름을 생략할 수 없다.
- 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다. 하지만 아래 예제에서는 함수 선언문이 변수에 할당되는 것처럼 보인다. 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다. 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.
  ```
  // 식별자          함수이름 
  var add = function add(x, y) {
    return x + y;
  }
  //         식별자
  console.log(add(2, 5)); 
  ```

### 12.4.2 함수 표현식
- 자바스크립트의 함수는 일급객체(값의 성질을 갖는 객체)다. 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다.
- 함수는 일급 객체이므로 함수 리터럴로 생성한 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수 표현식이라 한다.
  ```
  // 함수 표현식
  // 함수 리터럴의 함수 이름은 생략 가능 (익명함수)
  var add = function (x, y) {
    return x + y;
  };
  console.log(add(2, 5)); // 7
  ```
- 함수를 호출할 때는 함수 이름이 아니라 함수 객체를 가리키는 식별자를 사용해야 한다.
  ```
  // 기명 함수 표현식
  var add = function foo (x, y) {
    return x + y;
  };

  // 함수 객체를 가리키는 식별자로 호출
  console.log(add(2, 5)); // 7

  // 함수 이름은 함수 몸체 내부에서만 유요한 식별자다.
  console.log(foo(2, 5)); // ReferenceError
  ```

### 12.4.3 함수 생성 시점과 함수 호이스팅
```
// 함수 참조
console.dir(add); // f add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
}
```
- 함수 선언문으로 함수를 정의하면 코드가 한 줄씩 순차적으로 실행되는 시점인 런타임 이전에 함수 객체가 먼저 생성된다. 따라서 런타임에는 함수 선언문 이전에 함수를 참조할 수 있으며 호출할 수도 있다. 
- 함수 선언문이 코드 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅이라 한다.
- var 키워드로 선언된 변수는 undefined로 초기화되고, 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화된다.
- 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.

### 12.4.4 Function 생성자 함수
```
var add = new Function('x', 'y', `return x + y`);
console.log(add(2, 5)); // 7
```
- 함수 선언문이나 함수 표현식으로 생성한 함수와 Function 생성자 함수로 생성한 함수는 동일하게 동작하지 않는다.
- Function 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지도 않다.

### 12.4.5 화살표 함수
```
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```
- ES6에서 도입된 화살표 함수는 function 키워드 대신 화살표 => 를 사용해 좀 더 간략한 방법으로 함수를 선언할 수 있다.
- 화살표 함수는 항상 익명 함수로 정의한다.

## 12.5 함수 호출
### 12.5.1 매개변수와 인수
- 함수를 실행하기 위해 필요한 값을 함수 외부에서 함수 내부로 전달할 필요가 있는 경우, 매개변수(인자)를 통해 인수를 전달한다.
  ```
  // x, y : 매개변수
  function add(x, y) {
    return x + y;
  }
  // 2, 5 : 인수
  var result = add(2, 5);
  ```

### 12.5.2 인수 확인
- 함수를 정의할 때 적절한 인수가 전달되었는지 확인할 필요가 있다.
  ```
  function add(x, y) {
    if(typeof x !== 'number' || typeof y !== 'number') {
      throw enw TypeError('인수는 모두 숫자 값이어야 합니다.');
    }
    return x + y;
  }

  console.log(add(2));        // TypeError: 인수는 모두 숫자 값이어야 합니다.
  console.log(add('a', 'b')); // TypeError: 인수는 모두 숫자 값이어야 합니다.
  ```
- ES6에서 도입된 매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다. 매개변수 기본값은 매개변수에 인수를 전달하지 않았을 경우와 undefined를 전달한 경우에만 유효하다.
  ```
  function add(a = 0, b = 0, c = 0) {
    return a + b + c;
  }

  console.log(add(1, 2, 3)); // 6
  console.log(add(1, 2)); // 3
  console.log(add()); // 0
  ```

### 12.5.3 매개변수의 최대 개수
- 매개변수의 최대 개수에 대한 제한은 없지만, 이상적인 함수는 한 가지 일만 해야하며 가급적 작게 만들어야하므로 매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다.
- 만약 그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달하는 것이 유리하다.

### 12.5.4 반환문
- 반환문의 역할
  1. 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다. 따라서 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다.
      ```
      function multiply(x, y) {
        return x * y; 
        console.log('실행되지 않는다.');
      }

      console.log(multiply(3, 5)); // 15
      ```
  2. 반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환한다. return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.
      ```
      function foo() {
        return;
      }

      console.log(foo()); // undefined
      ```

## 12.6 참조에 의한 전달과 외부 상태의 변경
```
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = 'Kim';
}

var num = 100;
var person = { name: 'Lee' };

// 원시 값은 값 자체가 복사되어 전달되고, 객체는 참조 값이 복사되어 전달된다.
changeVal(num, person);

// 원시 값은 원본이 훼손되지 않는다.
console.log(num); // 100
// 객체는 원본이 훼손된다.
console.log(person); // {name: "Kim"}
```
- 원시 타입 인수는 값 자체가 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 그 값을 변경해도 원본은 훼손되지 않는다.
- 객체 타입 인수는 참조 값이 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 참조 값을 통해 객체를 변경할 경우 원본이 훼손된다.
- 함수가 외부상태를 변경하면 상태 변화를 추적하기 어려워지고 코드의 복잡성을 증가시키며 가독성을 해치는 원인이 된다.
- 이러한 문제의 해결 방법 중 하나는 객체를 불변객체(객체를 마치 원시 값처럼 변경 불가능한 값으로 동작하게 만드는 것)로 만들어 사용하는 것이다.

## 12.7 다양한 함수의 형태
### 12.7.1 즉시 실행 함수
```
// 익명 즉시 실행 함수
(function () {
  var a = 3;
  var b = 5;
  return a * b;
}());
```
- 함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라고 한다.
- 단 한번만 호출되며 다시 호출할 수 없다.
- 함수 이름이 없는 익명 함수를 사용하는 것이 일반적이다.
- 반드시 그룹 연산자 (...)로 감싸야한다.
- 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있고 인수를 전달할 수도 있다.

### 12.7.2 재귀 함수
- 재귀 함수는 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수를 말한다.
- 재귀 함수를 사용하면 반복되는 처리를 반복문 없이 구현할 수 있다.
  ```
  function countdown(n) {
    for(var i = n; i > 0; i--) console.log(i);
  }
  countdown(10);
  ```
  ```
  function countdown(n) {
    if(n < 0) return;
    console.log(n);
    countdown(n - 1); // 재귀 호출
  }
  countdown(10);
  ```
- 재귀 함수는 자신을 무한 재귀 호출하므로, 재귀 함수 내에는 재귀 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 한다.

### 12.7.3 중첩 함수
- 함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수라고 하며, 중첩 함수를 포함하는 함수는 외부 함수라 부른다.
  ```
  function outer() {
    var x = 1;

    // 중첩 함수
    function inner() {
      var y = 2;
      console.log(x + y); // 3
    }
    inner();
  }
  outer();
  ```

### 12.7.4 콜백 함수
```
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i);
  }
}

var logAll = function(i) {
  console.log(i);
}

// 반복 호출할 함수를 인수로 전달한다.
repeat(5, logAll); // 0 1 2 3 4
```
- 콜백 함수: 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
- 고차 함수: 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수
- 콜백 함수는 고차 함수에 의해 호출되며 이떄 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.
- 콜백 함수는 함수형 프로그래밍 패러다임뿐만 아니라 비동기 처리(이벤트 처리, Ajax 통신, 타이머 함수 등)에 활용되는 중요한 패턴이다.
  ```
  // 이벤트 처리
  document.getElementById('myButton').addEventListener('click', function() {
    console.log('button clicked');
  })

  // 비동기 처리
  setTimeout(function() {
    console.log('1초 경과');
  }, 1000);
  ```
- 콜백 함수는 배열 고차 함수에서도 사용된다.
  ```
  var res = [1, 2, 3].map(function (item) {
    return item * 2;
  });
  console.log(res); // [2, 4, 6]
  ```

### 12.7.5 순수 함수와 비순수 함수
- 순수 함수: 외부 상태에 의존하지도 않고 변경하지도 않는, 부수 효과가 없는 함수
  ```
  var count = 0;

  // 순수 함수
  function increase(n) {
    return ++n;
  }

  count = increase(count);
  console.log(count); // 1
  ```
- 비순수 함수: 외부 상태에 의존하거나 외부 상태를 변경하는, 부수 효과가 있는 함수
  ```
  var count = 0;

  // 비순수 함수
  function increase() {
    return ++count; // 외부 상태에 의존하며 외부 상태를 변경함
  }

  increase();
  console.log(count); // 1
  ```
- 함수 내부에서 외부 상태를 직접 참조하지 않더라도 매개변수를 통해 객체를 전달받으면 비순수 함수가 된다.
- 함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워지기 때문에 함수 외부 상태 변경을 지양하는 순수 함수를 사용하는 것이 좋다.