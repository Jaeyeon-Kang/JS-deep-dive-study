전역변수의 무분별한 사용은 위험하다. 앞으로 그에 대한 이유가 쭉 나온다.

## 변수의 생명 주기

### 지역 변수의 생명 주기

- 지역 변수의 생명 주기는 함수가 호출되면 생성되고 함수가 종료하면 소멸하기 때문에 전역변수보다 생명주기가 짧다.
- 지역 변수의 생명 주기는 함수의 생명주기라고 할 수 있다.
- 변수는 자신이 등록된 스코프가 소멸될때까지 유효하며, 더 이상 할당된 메모리공간을 참조하지 않을 때 가비지 콜렉터에 의해 해제되어 `가용 메모리 풀`에 반환된다.
- 아래는 호이스팅에 대한 예시이다.

```
var x = 'global'

function foo(){
    console.log(x); // var x  ------1
    var x = 'local'; // x='local'
}

foo();
console.log(x); -----2
```

- 1번은 undefined, 2번은 global로 찍힌다. 왜냐면, 지역 변수 x가 선두로 끌어올려진 것처럼 동작하는 호이스팅이 발생했기 때문이다.

### 전역 변수의 생명 주기

- 전역 변수의 생명 주기는 웹페이지를 닫을 때까지 유효하다.
- 브라우저 환경에서 전역 객체는 window이므로 브라우저 환경에서 var 키워드로 선언한 전역 변수는 window의 프로퍼티다.

## 전역 변수의 문제점

- 전역 변수는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 `암묵적 결합`을 허용하기 때문에 가독성이 나빠지고 위험해진다.
- 생명주기가 길어서 메모리 리소스를 오랜 기간 소비한다.
- 스코프 체인 상에서 종점에 존재한다. 이는 변수를 검색할 때 전역 변수가 가장 마지막에 검색된다는 것으로 전역 변수의 검색 속도가 가장 느리다.
- 네임 스페이스가 오염된다. 파일이 분리되어 있어도 하나의 전역 스코프를 공유해서 예상치 못한 결과를 초래할 수 있다.

## 전역 변수의 사용을 억제하는 방법

- 즉시 실행 함수를 사용한다.
- 네임스페이스 객체를 사용한다.

```
var MYAPP = {}; // 전역 네임스페이스 객체
MYAPP.name = 'Lee';
console.log(MYAPP.name); // Lee
```

### 모듈 패턴

모듈 패턴은 `캡슐화`를 통해 `정보 은닉`을 하기 위해 사용한다.
`캡슐화`: 객체의 상태를 나타내는 '프로퍼티'와 프로퍼티를 참조하고 조작할 수 있는 동작인 '매서드'를 하나로 묶는 것. 특정 프로퍼티나 매서드를 감출 목적으로 사용하기도 함.

```
var Counter = (function () {
    // private 변수
    var num = 0;

    // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
    return {
        increase(){
            return ++num;
        },
        decrease(){
            return --num;
        }
    }
}());

console.log(Counter.num); // undefined
console.log(Counter.increase()); // 1
console.log(Counter.decrease()); // 0
```
