## var 키워드로 선언한 변수의 문제점

### 변수 중복 선언 허용

- var 키워드로 선언한 변수는 중복 선언이 가능하다. var키워드를 중복 선언하면 var 키워드가 없는 것처럼 동작한다. 이는 의도치 않게 값이 변경되는 부작용을 초래한다.

### 함수 레벨 스코프

- var키워드는 함수 레벨 스코프이다. 따라서 함수 외부에서 var키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.

### 변수 호이스팅

- var 키워드로 변수를 선언하면 오류를 발생시킬 여지를 남긴다.

```
// 변수 foo는 선언과 동시에 undefined로 초기화된다.
console.log(foo) // undefined
foo = 123
console.log(foo) //123
var foo;
```

## let 키워드

### 변수의 중복 선언 금지

- let은 var와 달리 변수를 중복 선언할 경우 문법 에러가 난다.

### 블록 레벨 스코프

- let은 블록 레벨 스코프다. 전역에서는 블록 내 let키워드로 선언된 지역 변수를 참조할 수 없다.

### 변수 호이스팅

- let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것`처럼` 동작한다.
- 사실 호이스팅 자체는 일어나지만, 선언 단계가 먼저 일어나고 일시적 사각지대인 TDZ가 존재한 뒤 초기화 단계가 일어나므로 초기화 되기 전에는 변수를 참조할 수 없다.
- 하지만 호이스팅이 일어나지 않는 것은 아니다. 그 증명인 아래 예시에 따르면 변수 호이스팅이 발생하지 않으면 전역 변수 foo의 값을 출력해야 하지만, 그렇지 않고 참조 에러가 나는 난다.

```
let foo = 1;
{
    console.log(foo) // reference error
    let foo=2; // 지역변수
}
```

- 자바스크립트는 ES6에서 도입된 모든 선언(var, let, const, function, function\*, class등)을 호이스팅하지만 let, const, class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다.

### 전역 객체와 let

- var 키워드로 선언한 전역 변수, 전역 함수, 암묵적 전역은 브라우저의 window의 프로퍼티가 되며 이때 window는 생략할 수 있다.
- let은 전역 객체의 프로퍼티가 아니므로 window.foo처럼 접근할 수 없다.

## const 키워드

### 선언과 초기화

- const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 하며 그렇지 않으면 문법 에러가 발생한다.
- let과 마찬가지로 블록 레벨 스코프를 가지며, 변수 호이스팅이 발생하지 않는 것처럼 동작한다.

### 재할당 금지

- const는 재할당이 금지된다.

### 상수

- const 키워드로 선언한 변수에 원시 값을 할당한 경우 변수 값을 변경할 수 없다. 원시값은 변경할 수 없는 값이기 때문이다.

### const 키워드와 객체

- const 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있다. 객체는 변경 가능하기 때문이다.

```
// const person은 메모리 주소가 고정되는 것이지, 그 주소가 가리키는 값(객체의 속성)까지 고정되는 건 아니다.
// 즉, 새로운 객체로 교체할 수는 없지만, 기존 객체의 프로퍼티 값은 수정할 수 있다.
const person = {
    name: 'Lee'
}

person.name='Kim'
console.log(person) // {name: 'Kim'}
```

- 참고로 원시형처럼 완전히 수정 불가능하게 만들고 싶다면 Object.freeze 같은 메서드를 사용하면 된다.
